      SUBROUTINE IXGB(LUGB,LSKIP,LGRIB,NLEN,NNUM,CBUF)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: IXGB           MAKE INDEX RECORD
C   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 95-10-31
C
C ABSTRACT: THIS SUBPROGRAM MAKES ONE INDEX RECORD.
C       BYTE 001-004: BYTES TO SKIP IN DATA FILE BEFORE GRIB MESSAGE
C       BYTE 005-008: BYTES TO SKIP IN MESSAGE BEFORE PDS
C       BYTE 009-012: BYTES TO SKIP IN MESSAGE BEFORE GDS (0 IF NO GDS)
C       BYTE 013-016: BYTES TO SKIP IN MESSAGE BEFORE BMS (0 IF NO BMS)
C       BYTE 017-020: BYTES TO SKIP IN MESSAGE BEFORE BDS
C       BYTE 021-024: BYTES TOTAL IN THE MESSAGE
C       BYTE 025-025: GRIB VERSION NUMBER
C       BYTE 026-053: PRODUCT DEFINITION SECTION (PDS)
C       BYTE 054-095: GRID DEFINITION SECTION (GDS) (OR NULLS)
C       BYTE 096-101: FIRST PART OF THE BIT MAP SECTION (BMS) (OR NULLS)
C       BYTE 102-112: FIRST PART OF THE BINARY DATA SECTION (BDS)
C       BYTE 113-152: (OPTIONAL) BYTES 41-80 OF THE PDS
C
C PROGRAM HISTORY LOG:
C   95-10-31  IREDELL
C
C USAGE:    CALL WRGI1R(LUGB,LSKIP,LGRIB,LUGI)
C   INPUT ARGUMENTS:
C     LUGB         INTEGER LOGICAL UNIT OF INPUT GRIB FILE
C     LSKIP        INTEGER NUMBER OF BYTES TO SKIP BEFORE GRIB MESSAGE
C     LGRIB        INTEGER NUMBER OF BYTES IN GRIB MESSAGE
C     NLEN         INTEGER LENGTH OF EACH INDEX RECORD IN BYTES
C     NNUM         INTEGER INDEX RECORD NUMBER TO MAKE
C   OUTPUT ARGUMENTS:
C     CBUF         CHARACTER*1 (MBUF) BUFFER TO RECEIVE INDEX DATA
C
C SUBPROGRAMS CALLED:
C   GBYTE        GET INTEGER DATA FROM BYTES
C   SBYTE        STORE INTEGER DATA IN BYTES
C   BAREAD       BYTE-ADDRESSABLE READ
C
C ATTRIBUTES:
C   LANGUAGE: CRAY FORTRAN
C
C$$$
      CHARACTER CBUF(*)
      PARAMETER(LINDEX=152)
      PARAMETER(IXSKP=0,IXSPD=4,IXSGD=8,IXSBM=12,IXSBD=16,IXLEN=20,
     &          IXVER=24,IXPDS=25,IXGDS=53,IXBMS=95,IXBDS=101,
     &          IXPDX=112)
      PARAMETER(MXSKP=4,MXSPD=4,MXSGD=4,MXSBM=4,MXSBD=4,MXLEN=4,
     &          MXVER=1,MXPDS=28,MXGDS=42,MXBMS=6,MXBDS=11,
     &          MXPDX=40)
      CHARACTER CBREAD(LINDEX),CINDEX(LINDEX)
C
C  INITIALIZE INDEX RECORD AND READ GRIB MESSAGE
C
      DO I=1,LINDEX
        CINDEX(I)=CHAR(0)
      ENDDO
      CALL SBYTE(CINDEX,LSKIP,8*IXSKP,8*MXSKP)
      CALL SBYTE(CINDEX,LGRIB,8*IXLEN,8*MXLEN)
C
C  PUT PDS IN INDEX RECORD
C
      ISKPDS=8
      IBSKIP=LSKIP
      IBREAD=ISKPDS+MXPDS
      CALL BAREAD(LUGB,IBSKIP,IBREAD,LBREAD,CBREAD)
      IF(LBREAD.NE.IBREAD) CALL ABORT
      CINDEX(IXVER+1)=CBREAD(8)
      CALL SBYTE(CINDEX,ISKPDS,8*IXSPD,8*MXSPD)
      CALL GBYTE(CBREAD,LENPDS,8*ISKPDS,8*3)
      CALL GBYTE(CBREAD,INCGDS,8*ISKPDS+8*7+0,1)
      CALL GBYTE(CBREAD,INCBMS,8*ISKPDS+8*7+1,1)
      ILNPDS=MIN(LENPDS,MXPDS)
      DO I=1,ILNPDS
       CINDEX(IXPDS+I)=CBREAD(ISKPDS+I)
      ENDDO
C
      ISKTOT=ISKPDS+LENPDS
C 
C  PUT PDS EXTENSION IN INDEX RECORD
C
      IF(LENPDS.GT.40) THEN
        ISKPDX=ISKPDS+40
        IBSKIP=LSKIP+ISKPDX
        IBREAD=MXPDX
        CALL BAREAD(LUGB,IBSKIP,IBREAD,LBREAD,CBREAD)
        IF(LBREAD.NE.IBREAD) CALL ABORT
        ILNPDX=MIN(LENPDS-40,MXPDX)
        DO I=1,ILNPDX
         CINDEX(IXPDX+I)=CBREAD(I)
        ENDDO
      ENDIF
C
C  PUT GDS IN INDEX RECORD
C
      IF(INCGDS.NE.0) THEN
        ISKGDS=ISKTOT
        IBSKIP=LSKIP+ISKGDS
        IBREAD=MXGDS
        CALL BAREAD(LUGB,IBSKIP,IBREAD,LBREAD,CBREAD)
        IF(LBREAD.NE.IBREAD) CALL ABORT
        CALL SBYTE(CINDEX,ISKGDS,8*IXSGD,8*MXSGD)
        CALL GBYTE(CBREAD,LENGDS,0,8*3)
        ILNGDS=MIN(LENGDS,MXGDS)
        DO I=1,ILNGDS
          CINDEX(IXGDS+I)=CBREAD(I)
        ENDDO
        ISKTOT=ISKGDS+LENGDS
      ENDIF
C
C  PUT BMS IN INDEX RECORD
C
      IF(INCBMS.NE.0) THEN
        ISKBMS=ISKTOT
        IBSKIP=LSKIP+ISKBMS
        IBREAD=MXBMS
        CALL BAREAD(LUGB,IBSKIP,IBREAD,LBREAD,CBREAD)
        IF(LBREAD.NE.IBREAD) CALL ABORT
        CALL SBYTE(CINDEX,ISKBMS,8*IXSBM,8*MXSBM)
        CALL GBYTE(CBREAD,LENBMS,0,8*3)
        ILNBMS=MIN(LENBMS,MXBMS)
        DO I=1,ILNBMS
          CINDEX(IXBMS+I)=CBREAD(I)
        ENDDO
        ISKTOT=ISKBMS+LENBMS
      ENDIF
C
C  PUT BDS IN INDEX RECORD
C
      ISKBDS=ISKTOT
      IBSKIP=LSKIP+ISKBDS
      IBREAD=MXBDS
      CALL BAREAD(LUGB,IBSKIP,IBREAD,LBREAD,CBREAD)
      IF(LBREAD.NE.IBREAD) CALL ABORT
      CALL SBYTE(CINDEX,ISKBDS,8*IXSBD,8*MXSBD)
      CALL GBYTE(CBREAD,LENBDS,0,8*3)
      ILNBDS=MIN(LENBDS,MXBDS)
      DO I=1,ILNBDS
       CINDEX(IXBDS+I)=CBREAD(I)
      ENDDO
C
C  STORE INDEX RECORD
C
      NSKIP=NLEN*(NNUM-1)
      NSTORE=MIN(NLEN,LINDEX)
      DO I=1,NSTORE
       CBUF(NSKIP+I)=CINDEX(I)
      ENDDO
      DO I=1,NLEN-NSTORE
       CBUF(NSKIP+NSTORE+I)=CHAR(0)
      ENDDO
C
      RETURN
      END
